#include "stdafx.h"
#include "HandleDraw.h"
#include "HandleEvent.h"
#include "Pen.h"
#include "Helper.h"
#include "Shape.h"
#include "Line.h"
#include "Rectangle.h"
#include "Square.h"
#include "Ellipse.h"
#include "Circle.h"

#include <commdlg.h>

//Init static attribute
CHOOSECOLOR  HandleDraw::_cc;
COLORREF  HandleDraw::_acrCustClr[16];
DWORD HandleDraw::_color = RGB(0, 0, 0);
HBRUSH  HandleDraw::_hbrush;
std::vector<std::shared_ptr<Shape>> HandleDraw::_draggedShapes;


//Helper for onPaint
// Get a ptr to a figure which was generated by fromX, fromY, toX, toY
std::shared_ptr<figure::Figure> HandleDraw::getFigureToDraw(int typeFigure, 
	int left, int top, int right, int bottom) {

	if (TYPE_ELLIPSE == typeFigure) return std::make_shared<figure::Ellipse>
		(figure::Point(left, top), figure::Point(right, bottom));
	if (TYPE_RECTANGLE == typeFigure) return std::make_shared <figure::Rectangle>
		(figure::Point(left, top), figure::Point(right, bottom));
	if (TYPE_LINE == typeFigure) return	std::make_shared<figure::Line>
		(figure::Point(left, top), figure::Point(right, bottom));

	//Init for circle or square
	int dx = right - left;
	int dy = abs(dx);
	if (bottom - top < 0) dy *= -1;

	HandleEvent::toX = left + dx;
	HandleEvent::toY = top + dy;

	if (TYPE_CIRCLE == typeFigure) {
		return	std::make_shared<figure::Circle>
			(figure::Point(left, top), figure::Point(left + dx, top + dy));
	}

	if (TYPE_SQUARE == typeFigure) {
		return	std::make_shared<figure::Square>
			(figure::Point(left, top), figure::Point(left + dx, top + dy));
	}

	return nullptr;
}

void HandleDraw::initToDraw(HDC& hdc, HDC& memDC, HBITMAP& memBMP) {
		
	//Create a memoryDC as a temp DC:
	//We will paint everything into memoryDC and copy data from memoryDC -> DC
	//	This will make you do not erase figures which are in DC 
	//	when you are in Preview mode
	memDC = CreateCompatibleDC(hdc);
	memBMP = CreateCompatibleBitmap(hdc,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top);
	SelectObject(memDC, memBMP);
	FillRect(memDC, &HandleEvent::rcHWND, (HBRUSH)(COLOR_WINDOW + 1));

	//this would make draw transparent figure
	SelectObject(memDC, GetStockObject(NULL_BRUSH));
}

void HandleDraw::drawIntoMemDC(HDC& memDC, Pen& pen, int type,
		int left, int top, int right, int bottom) {

	//Get the figure
	std::shared_ptr<figure::Figure> figure =
		getFigureToDraw(type, left, top, right, bottom);

	//Set the figure to draw
	pen.setFigure(figure);

	//Draw the figure
	pen.draw(memDC);
}

void HandleDraw::traversalStates(void(*process)(int, int, std::vector<std::shared_ptr<Shape>>&), std::vector<std::shared_ptr<Shape>>& shapes) {
	for (int i = HandleEvent::states.size() - 1; i >= 0; --i) {
		for (int j = HandleEvent::states[i].size() - 1; j >= 0; --j) {
			if (HandleEvent::states[i][j]->isValid &&
				HandleEvent::states[i][j]->figure->isIn(HandleEvent::rcSelectOriginal)) {
				process(i, j, shapes);
			}
		}
	}
}

void HandleDraw::modePreview(HDC& hdc, HDC& memDC, int mode) {
	if (MODE_PREVIEW != mode) return;

	Pen::drawAll(memDC);
	Pen pen(memDC, PS_DASHDOT, 3, _color);
	drawIntoMemDC(memDC, pen);

	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}

void HandleDraw::modeDraw(HDC& hdc, HDC& memDC, int mode) {
	if (MODE_DRAW != mode) return;

	Pen::drawAll(memDC);
	Pen pen(memDC, PS_DASHDOT, 3, _color);
	drawIntoMemDC(memDC, pen);

	//Save true shape
	pen.saveShape();

	//Deactivated draw mode
	//mode = MODE_NULL;

	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}

void HandleDraw::modeDrawPause(HDC& hdc, HDC& memDC, int mode) {
	if (MODE_SELECT_CANCEL != mode) return;
	
	//Only redraw all
	Pen::drawAll(memDC);

	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}

void HandleDraw::modeSelect(HDC& hdc, HDC& memDC, int mode) {
	if (MODE_SELECT != mode) return;

	Pen pen(memDC);
	Pen::drawAll(memDC);

	//Set style to draw rcSelect
	pen.setStyle(memDC, PS_DASHDOT, 1, RGB(0, 0, 255));

	//Draw preview of rcSelect
	drawIntoMemDC(memDC, pen);

	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}

void HandleDraw::modeDrag(HDC& hdc, HDC& memDC, bool isDragAfterDrawType, int mode) {
	if (MODE_DRAG != mode) return;

	Pen pen(memDC);			//Pen to draw rcSelected
	Pen::drawAll(memDC);

	//If there is no seleted shape before
	if (_draggedShapes.empty()) {
		//Find the shapes which are in rcSelect
		for (int i = HandleEvent::states.size() - 1; i >= 0; --i) {
			for (int j = HandleEvent::states[i].size() - 1; j >= 0; --j) {
				if (HandleEvent::states[i][j]->isValid &&
					HandleEvent::states[i][j]->figure->isIn(HandleEvent::rcSelectOriginal)) {

					//Save the shape to drag
					_draggedShapes.push_back(std::make_shared<Shape>(*HandleEvent::states[i][j]));
					//_draggedShapes.back().color = _color;
					_draggedShapes.back()->executedFrom = HandleEvent::states[i][j];
					_draggedShapes.back()->figure = HandleEvent::states[i][j]->figure->duplicate();

					//invalidate the selected shape (which mean this cannot be drawn)
					// We do not delete the old seletected shape because of undoing/redoing
					HandleEvent::states[i][j]->isValid = false;
					if (isDragAfterDrawType) break;	//Get only the last figure when in this mode
				}
			}
			if (isDragAfterDrawType) break;	//Get only the last figure when in this mode
		}
	}

	//Drag rcSelect
	pen.setStyle(memDC, PS_DASHDOT, 1, RGB(0, 0, 255));
	drawIntoMemDC(memDC, pen, TYPE_RECTANGLE,
		HandleEvent::rcSelect.left, HandleEvent::rcSelect.top, 
		HandleEvent::rcSelect.right, HandleEvent::rcSelect.bottom);

	//Drag the selected figure
	if (!_draggedShapes.empty()) {
		if (!(0 == HandleEvent::dx && 0 == HandleEvent::dy)) {
			for (std::shared_ptr<Shape> i : _draggedShapes) {
				i->figure->move(figure::Point(HandleEvent::dx, HandleEvent::dy));
			}
		}
		Pen::drawAll(memDC, _draggedShapes);
	}

	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}

void HandleDraw::modeChangeColor(HDC& hdc, HDC& memDC, int mode) {
	if (MODE_CHANGECOLOR != mode) return;

	Pen pen(memDC);			//Pen to draw rcSelected
	Pen::drawAll(memDC);
	
	//Change color while states[i][j] is valid, not deleted and is in rcSelect
	auto changeColor = [](int i, int j, std::vector<std::shared_ptr<Shape>>& _draggedShapes) {
		//Save the shape to drag
		_draggedShapes.push_back(std::make_shared<Shape>(*HandleEvent::states[i][j]));
		_draggedShapes.back()->color = _color;
		_draggedShapes.back()->executedFrom = HandleEvent::states[i][j];
		_draggedShapes.back()->figure = HandleEvent::states[i][j]->figure->duplicate();

		//invalidate the selected shape (which mean this cannot be drawn)
		// We do not delete the old seletected shape because of undoing/redoing
		HandleEvent::states[i][j]->isValid = false;
	};

	//Check if there are some dragged shapes before
	if (_draggedShapes.empty()) {
		traversalStates(changeColor, _draggedShapes);
	}
	else {
		for (unsigned int i = 0; i < _draggedShapes.size(); ++i) {
			_draggedShapes[i]->color = _color;
		}
	}

	//Drag rcSelect
	pen.setStyle(memDC, PS_DASHDOT, 1, RGB(0, 0, 255));
	drawIntoMemDC(memDC, pen, TYPE_RECTANGLE,
		HandleEvent::rcSelect.left, HandleEvent::rcSelect.top,
		HandleEvent::rcSelect.right, HandleEvent::rcSelect.bottom);

	Pen::drawAll(memDC, _draggedShapes);
	
	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}

/*
void HandleDraw::modeDelete(HDC& hdc, HDC& memDC, int mode) {
	if (MODE_DELETE != mode) return;

	//If a shape is delete, it would have:
	//	- A duplicate in the top of states, which have isDeleted = true, and is executedFrom = &original
	//a duplicate is make for undoing/redoing
	//	- set the orginal one's isDeleted = true
	auto deleteCheck = [](int i, int j, std::vector<Shape>& _draggedShapes) {
		//Save the shape to drag
		_draggedShapes.push_back(HandleEvent::states[i][j]);
		_draggedShapes.back().executedFrom = &HandleEvent::states[i][j];
		_draggedShapes.back().figure = HandleEvent::states[i][j].figure->duplicate();
		_draggedShapes.back().isDeleted = true;

		//invalidate the selected shape (which mean this cannot be drawn)
		// We do not delete the old seletected shape because of undoing/redoing
		HandleEvent::states[i][j].isDeleted = true;
	};


	//Check if there are some dragged shapes before
	if (_draggedShapes.empty()) {
		traversalStates(deleteCheck);
		Pen::drawAll(memDC);
		Pen::drawAll(memDC, _draggedShapes);
	}
	else {
		for (unsigned int i = 0; i < _draggedShapes.size(); ++i) {
			_draggedShapes[i].isDeleted = true;
		}
		Pen::drawAll(memDC);
		Pen::drawAll(memDC, _draggedShapes);
	}

	//Copy data from memoryDC -> hdc
	BitBlt(hdc, 0, 0,
		HandleEvent::rcHWND.right - HandleEvent::rcHWND.left,
		HandleEvent::rcHWND.bottom - HandleEvent::rcHWND.top,
		memDC, 0, 0, SRCCOPY);
}*/


DWORD HandleDraw::color() {
	return _color;
}

	//After dragging, if there are some selected shapes
	//	=> push back into states and clear all current selected shapes
void HandleDraw::finishToDrag(std::vector<std::vector<std::shared_ptr<Shape>>>& states) {
	if (!_draggedShapes.empty()) {
		if (states.empty()) {
			states.push_back(_draggedShapes);
		}
		else {
			std::vector<std::shared_ptr<Shape>> top = states.back();
			if (!Helper::isNotMove(top, _draggedShapes)) {
				states.push_back(_draggedShapes);
			}
		}
		_draggedShapes.clear();
	}
}

	//Choose color from menu
void HandleDraw::chooseColor(HWND& hwnd) {
	ZeroMemory(&_cc, sizeof(CHOOSECOLOR));
	_cc.lStructSize = sizeof(CHOOSECOLOR);
	_cc.hwndOwner = hwnd;
	_cc.lpCustColors = (LPDWORD)_acrCustClr;
	_cc.rgbResult = _color;
	_cc.Flags = CC_FULLOPEN | CC_RGBINIT;
	if (ChooseColor(&_cc)) {
		_hbrush = CreateSolidBrush(_cc.rgbResult);
		_color = _cc.rgbResult;
	}
}

void HandleDraw::activateDrawShape(int& mode, int type) {
	if (HandleEvent::isAfterDraw) {
		HandleDraw::finishToDrag(HandleEvent::states);
		HandleEvent::isAfterDraw = false;
	}
	mode = MODE_NULL;
	HandleEvent::typeFigure = type;
}

void HandleDraw::activateSelect(int& mode) {
	if (HandleEvent::isAfterDraw) {
		HandleDraw::finishToDrag(HandleEvent::states);
		HandleEvent::isAfterDraw = false;
	}
	HandleEvent::typeFigure = TYPE_NULL;
	mode = MODE_SELECT;
}

void HandleDraw::activateChooseColor(HWND& hwnd, int& mode) {

	chooseColor(hwnd);

	//Changed color while in drag mode
	if (MODE_DRAG == mode) {

		//Clear redo 
		HandleEdit::clearRedoStates();

		//end drag mode temporaly
		//start change color mode
		mode = MODE_CHANGECOLOR;

		//Change color immediately
		InvalidateRect(hwnd, &HandleEvent::rcHWND, FALSE);
		UpdateWindow(hwnd);

		//Back to drag mode to keep dragging
		mode = MODE_DRAG;
		return;
	}
	else {
		//Changed color casually: change color -> draw
		mode = MODE_PREVIEW;
	}
}